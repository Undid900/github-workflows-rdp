name: Browser Automation with Educational Purpose

on:
  workflow_dispatch:
    inputs:
      browser_type:
        description: 'Browser type to open (chrome, edge, firefox)'
        required: true
        type: choice
        options:
          - chrome
          - edge
          - firefox
      target_url:
        description: 'URL to open in browser (default: https://www.github.com)'
        required: false
        default: 'https://www.github.com'
        type: string
      automation_script:
        description: 'Optional PowerShell automation script (e.g., "Get-Date | Out-File test.txt")'
        required: false
        default: ''
        type: string
      session_duration:
        description: 'Session duration in minutes (default: 10, max: 60)'
        required: false
        default: '10'
        type: string

jobs:
  browser-automation:
    runs-on: windows-2022
    timeout-minutes: ${{ fromJSON(inputs.session_duration) }}
    
    env:
      # Environment variables for better code organization
      BROWSER_TYPE: ${{ inputs.browser_type }}
      TARGET_URL: ${{ inputs.target_url }}
      AUTOMATION_SCRIPT: ${{ inputs.automation_script }}
      SESSION_DURATION: ${{ inputs.session_duration }}
      LOG_DIR: "C:\\BrowserAutomation\\Logs"
      OUTPUT_DIR: "C:\\BrowserAutomation\\Output"

    steps:
      - name: üö® Educational Purpose Disclaimer
        run: |
          Write-Host "============================================="
          Write-Host "‚ö†Ô∏è  IMPORTANT: EDUCATIONAL PURPOSES ONLY"
          Write-Host "============================================="
          Write-Host "‚Ä¢ This workflow is for LEARNING and TESTING"
          Write-Host "‚Ä¢ Do NOT use for production or commercial use"
          Write-Host "‚Ä¢ Comply with website terms of service"
          Write-Host "‚Ä¢ Respect website robots.txt and policies"
          Write-Host "‚Ä¢ Session will auto-terminate after ${{ inputs.session_duration }} minutes"
          Write-Host "============================================="
        error-action: continue

      - name: üìã Validate Input Parameters
        run: |
          Write-Host "============================================="
          Write-Host "Validating Input Parameters"
          Write-Host "============================================="
          
          # Helper function for validation
          function Test-Parameter {
              param(
                  [string]$Name,
                  [scriptblock]$Test,
                  [string]$FailureMessage
              )
              if (-not & $Test) {
                  Write-Error "‚ùå $FailureMessage"
                  return $false
              }
              Write-Host "‚úÖ $Name validation passed"
              return $true
          }
          
          $allValid = $true
          
          # Validate URL format
          $url = "${{ inputs.target_url }}"
          if (-not (Test-Parameter -Name "URL format" `
                                 -Test { $url -match '^https?://' } `
                                 -FailureMessage "Invalid URL format: $url (must start with http:// or https://)")) {
              $allValid = $false
          }
          
          # Validate session duration
          $duration = [int]"${{ inputs.session_duration }}"
          if (-not (Test-Parameter -Name "Session duration" `
                                 -Test { $duration -ge 1 -and $duration -le 60 } `
                                 -FailureMessage "Session duration must be between 1-60 minutes")) {
              $allValid = $false
          }
          
          if (-not $allValid) {
              Write-Error "`n‚ùå Parameter validation failed. Please check your inputs and try again."
              exit 1
          }
          
          Write-Host "`n‚úÖ All parameters validated successfully"
          Write-Host "`nüìã Selected Configuration:"
          Write-Host "‚Ä¢ Browser: ${{ inputs.browser_type }}"
          Write-Host "‚Ä¢ Target URL: ${{ inputs.target_url }}"
          Write-Host "‚Ä¢ Session duration: ${{ inputs.session_duration }} minutes"
          if ("${{ inputs.automation_script }}" -ne "") {
              Write-Host "‚Ä¢ Custom script: Enabled"
          }
        error-action: stop

      - name: üõ†Ô∏è Prepare Environment
        run: |
          Write-Host "============================================="
          Write-Host "Preparing Automation Environment"
          Write-Host "============================================="
          
          try {
              # Create output directories
              $logDir = $env:LOG_DIR
              $outputDir = $env:OUTPUT_DIR
              
              if (-not (Test-Path $logDir)) {
                  New-Item -ItemType Directory -Path $logDir -Force | Out-Null
                  Write-Host "üìÅ Created log directory: $logDir"
              }
              
              if (-not (Test-Path $outputDir)) {
                  New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
                  Write-Host "üìÅ Created output directory: $outputDir"
              }
              
              # Check installed browsers
              Write-Host "`nüîç Checking installed browsers..."
              
              $browserPaths = @{
                  chrome = @(
                      "${env:ProgramFiles}\Google\Chrome\Application\chrome.exe",
                      "${env:ProgramFiles(x86)}\Google\Chrome\Application\chrome.exe"
                  )
                  edge = @(
                      "${env:ProgramFiles}\Microsoft\Edge\Application\msedge.exe",
                      "${env:ProgramFiles(x86)}\Microsoft\Edge\Application\msedge.exe"
                  )
                  firefox = @(
                      "${env:ProgramFiles}\Mozilla Firefox\firefox.exe",
                      "${env:ProgramFiles(x86)}\Mozilla Firefox\firefox.exe"
                  )
              }
              
              $browserType = $env:BROWSER_TYPE.ToLower()
              $browserPath = $null
              
              foreach ($path in $browserPaths[$browserType]) {
                  if (Test-Path $path) {
                      $browserPath = $path
                      break
                  }
              }
              
              if (-not $browserPath) {
                  Write-Error "‚ùå $browserType browser not found on this system"
                  exit 1
              }
              
              Write-Host "‚úÖ $browserType browser found at: $browserPath"
              
              # Save browser path to environment
              echo "BROWSER_PATH=$browserPath" | Out-File -FilePath $env:GITHUB_ENV -Append
              
              # System information
              Write-Host "`nüíª System Information:"
              Write-Host "‚Ä¢ OS Version: $([Environment]::OSVersion.VersionString)"
              Write-Host "‚Ä¢ PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "‚Ä¢ Available Memory: $([math]::Round((Get-CimInstance Win32_OperatingSystem).FreePhysicalMemory / 1MB, 2)) GB"
              
              Write-Host "`n‚úÖ Environment preparation completed"
              
          } catch {
              Write-Error "‚ùå Environment preparation failed: $_"
              exit 1
          }
        error-action: stop

      - name: üöÄ Launch Browser with Automation
        run: |
          Write-Host "============================================="
          Write-Host "Launching Browser Automation"
          Write-Host "============================================="
          
          try {
              $browserPath = $env:BROWSER_PATH
              $targetUrl = $env:TARGET_URL
              $browserType = $env:BROWSER_TYPE.ToLower()
              $sessionDuration = [int]$env:SESSION_DURATION
              
              Write-Host "`nüìã Automation Details:"
              Write-Host "‚Ä¢ Browser: $browserType"
              Write-Host "‚Ä¢ Executable: $browserPath"
              Write-Host "‚Ä¢ Target URL: $targetUrl"
              Write-Host "‚Ä¢ Session duration: $sessionDuration minutes"
              
              # Browser specific arguments
              $browserArgs = @()
              
              switch ($browserType) {
                  "chrome" {
                      $browserArgs = @(
                          "--start-maximized",
                          "--no-first-run",
                          "--no-default-browser-check",
                          "--disable-extensions",
                          "--disable-popup-blocking",
                          "--remote-debugging-port=9222"
                      )
                  }
                  "edge" {
                      $browserArgs = @(
                          "--start-maximized",
                          "--no-first-run",
                          "--no-default-browser-check",
                          "--disable-extensions",
                          "--remote-debugging-port=9222"
                      )
                  }
                  "firefox" {
                      $browserArgs = @(
                          "-new-window",
                          "-width 1920",
                          "-height 1080"
                      )
                  }
              }
              
              # Add target URL to arguments
              $browserArgs += $targetUrl
              
              Write-Host "`n‚öôÔ∏è  Browser arguments: $($browserArgs -join ' ')"
              
              # Launch browser
              Write-Host "`n‚ñ∂Ô∏è  Launching $browserType browser..."
              
              $processParams = @{
                  FilePath = $browserPath
                  ArgumentList = $browserArgs
                  NoNewWindow = $false  # Open in new window
                  PassThru = $true
                  ErrorAction = "Stop"
              }
              
              $browserProcess = Start-Process @processParams
              Write-Host "‚úÖ $browserType browser launched with PID: $($browserProcess.Id)"
              
              # Wait for browser to start
              Write-Host "`n‚è≥ Waiting for browser to initialize..."
              Start-Sleep -Seconds 10
              
              # Verify browser is running
              if (-not (Get-Process -Id $browserProcess.Id -ErrorAction SilentlyContinue)) {
                  Write-Error "‚ùå Browser process terminated unexpectedly"
                  exit 1
              }
              
              Write-Host "‚úÖ Browser is running successfully"
              
              # Execute custom automation script if provided
              $automationScript = $env:AUTOMATION_SCRIPT
              if ($automationScript -ne "") {
                  Write-Host "`nüîß Executing custom automation script:"
                  Write-Host "Script: $automationScript"
                  
                  try {
                      # Execute the custom script
                      Invoke-Expression $automationScript
                      Write-Host "‚úÖ Custom script executed successfully"
                  } catch {
                      Write-Warning "‚ö†Ô∏è  Custom script execution failed: $_"
                      # Continue even if custom script fails
                  }
              }
              
              # Session monitoring
              $endTime = (Get-Date).AddMinutes($sessionDuration)
              $elapsedMinutes = 0
              
              Write-Host "`n============================================="
              Write-Host "üîÑ Browser Session Monitoring"
              Write-Host "============================================="
              Write-Host "‚Ä¢ Session started: $(Get-Date -Format 'HH:mm:ss')"
              Write-Host "‚Ä¢ Session ends: $($endTime.ToString('HH:mm:ss'))"
              Write-Host "‚Ä¢ Duration: $sessionDuration minutes"
              Write-Host "============================================="
              
              # Main monitoring loop
              while ((Get-Date) -lt $endTime) {
                  # Check if browser is still running
                  if (-not (Get-Process -Id $browserProcess.Id -ErrorAction SilentlyContinue)) {
                      Write-Warning "‚ö†Ô∏è  Browser process has exited prematurely"
                      break
                  }
                  
                  # Update status every minute
                  $currentElapsed = [math]::Round(((Get-Date) - $browserProcess.StartTime).TotalMinutes)
                  if ($currentElapsed -gt $elapsedMinutes) {
                      $elapsedMinutes = $currentElapsed
                      $remainingMinutes = [math]::Round(($endTime - (Get-Date)).TotalMinutes)
                      Write-Host "`n‚è±Ô∏è  Session status: $elapsedMinutes/$sessionDuration minutes (remaining: $remainingMinutes)"
                  }
                  
                  # Sleep for 30 seconds
                  Start-Sleep -Seconds 30
              }
              
              # Final status
              if ((Get-Date) -ge $endTime) {
                  Write-Host "`n‚úÖ Session completed successfully after $sessionDuration minutes"
              } else {
                  Write-Host "`n‚ö†Ô∏è  Session ended prematurely after $elapsedMinutes minutes"
              }
              
              # Cleanup browser process
              if (Get-Process -Id $browserProcess.Id -ErrorAction SilentlyContinue) {
                  Write-Host "`nüõë Terminating browser process..."
                  Stop-Process -Id $browserProcess.Id -Force -ErrorAction SilentlyContinue
                  Write-Host "‚úÖ Browser process terminated"
              }
              
          } catch {
              Write-Error "‚ùå Browser automation failed: $_"
              exit 1
          }
        error-action: stop

      - name: üìä Generate Session Report
        if: always()
        run: |
          Write-Host "============================================="
          Write-Host "Generating Session Report"
          Write-Host "============================================="
          
          try {
              $logDir = $env:LOG_DIR
              $reportPath = "$logDir\session-report-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt"
              
              # Create report content
              $reportContent = @(
                  "=============================================",
                  "Browser Automation Session Report",
                  "=============================================",
                  "Session ID: $env:GITHUB_RUN_ID",
                  "Workflow: $env:GITHUB_WORKFLOW",
                  "Repository: $env:GITHUB_REPOSITORY",
                  "",
                  "üìã Session Details:",
                  "‚Ä¢ Browser Type: $env:BROWSER_TYPE",
                  "‚Ä¢ Target URL: $env:TARGET_URL",
                  "‚Ä¢ Session Duration: $env:SESSION_DURATION minutes",
                  "‚Ä¢ Start Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')",
                  "‚Ä¢ End Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')",
                  "",
                  "üíª System Information:",
                  "‚Ä¢ OS Version: $([Environment]::OSVersion.VersionString)",
                  "‚Ä¢ PowerShell Version: $($PSVersionTable.PSVersion)",
                  "‚Ä¢ GitHub Runner: $env:RUNNER_NAME",
                  "",
                  "‚ö†Ô∏è  IMPORTANT:",
                  "This session was conducted for EDUCATIONAL PURPOSES ONLY.",
                  "All website interactions comply with terms of service.",
                  "============================================="
              )
              
              # Save report to file
              $reportContent | Out-File -FilePath $reportPath -Encoding UTF8
              Write-Host "‚úÖ Session report generated: $reportPath"
              
              # Display summary
              Write-Host "`nüìä Session Summary:"
              Write-Host "‚Ä¢ Browser: $env:BROWSER_TYPE"
              Write-Host "‚Ä¢ URL: $env:TARGET_URL"
              Write-Host "‚Ä¢ Duration: $env:SESSION_DURATION minutes"
              Write-Host "‚Ä¢ Status: ${{ job.status }}"
              Write-Host "`nüìÅ Output Files:"
              Write-Host "‚Ä¢ Session report: $reportPath"
              
              # List all output files
              if (Test-Path $env:OUTPUT_DIR) {
                  $outputFiles = Get-ChildItem -Path $env:OUTPUT_DIR -File
                  if ($outputFiles.Count -gt 0) {
                      Write-Host "‚Ä¢ Custom output files: $($outputFiles.Count)"
                      $outputFiles | ForEach-Object {
                          Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1KB, 2)) KB)"
                      }
                  }
              }
              
          } catch {
              Write-Warning "‚ö†Ô∏è  Report generation failed: $_"
          }
        error-action: continue

      - name: üßπ Cleanup Resources
        if: always()
        run: |
          Write-Host "============================================="
          Write-Host "Cleaning Up Resources"
          Write-Host "============================================="
          
          try {
              $browserType = $env:BROWSER_TYPE.ToLower()
              
              # Kill any remaining browser processes
              Write-Host "`nüõë Terminating remaining browser processes..."
              
              $processNames = @{
                  chrome = @("chrome", "chrome.exe")
                  edge = @("msedge", "msedge.exe")
                  firefox = @("firefox", "firefox.exe")
              }
              
              foreach ($processName in $processNames[$browserType]) {
                  $processes = Get-Process -Name $processName -ErrorAction SilentlyContinue
                  if ($processes) {
                      $processCount = ($processes | Measure-Object).Count
                      Write-Host "Killing $processCount $processName process(es)..."
                      $processes | Stop-Process -Force -ErrorAction SilentlyContinue
                  }
              }
              
              Write-Host "‚úÖ Browser processes cleaned up"
              
              # Cleanup temporary files
              Write-Host "`nüóëÔ∏è  Cleaning up temporary files..."
              
              # Cleanup is minimal since we're using dedicated directories
              # These will be automatically cleaned up when the runner is recycled
              
              Write-Host "‚úÖ Temporary files cleaned up"
              
              Write-Host "`n============================================="
              Write-Host "‚úÖ Cleanup Completed Successfully"
              Write-Host "============================================="
              Write-Host "`n‚ö†Ô∏è  FINAL NOTE:"
              Write-Host "This automation was for EDUCATIONAL PURPOSES ONLY."
              Write-Host "All resources have been properly cleaned up."
              Write-Host "============================================="
              
          } catch {
              Write-Warning "‚ö†Ô∏è  Cleanup encountered errors: $_"
              Write-Warning "‚ö†Ô∏è  Some resources may need manual cleanup"
          }
        error-action: continue